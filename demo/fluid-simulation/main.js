!function(e){var t={};function n(r){if(t[r])return t[r].exports;var i=t[r]={i:r,l:!1,exports:{}};return e[r].call(i.exports,i,i.exports,n),i.l=!0,i.exports}n.m=e,n.c=t,n.d=function(e,t,r){n.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:r})},n.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},n.t=function(e,t){if(1&t&&(e=n(e)),8&t)return e;if(4&t&&"object"==typeof e&&e&&e.__esModule)return e;var r=Object.create(null);if(n.r(r),Object.defineProperty(r,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var i in e)n.d(r,i,function(t){return e[t]}.bind(null,i));return r},n.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return n.d(t,"a",t),t},n.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},n.p="",n(n.s=0)}([function(e,t,n){"use strict";n.r(t);const r=(e,t,n)=>{const r=e.createShader(t);if(!r)throw new Error("can not create shader");if(e.shaderSource(r,n),e.compileShader(r),!e.getShaderParameter(r,e.COMPILE_STATUS)){const t="An error occurred compiling the shaders: "+e.getShaderInfoLog(r);throw e.deleteShader(r),new Error(t)}return r};class i{constructor(e,t,n){this.gl=e;const i=r(e,e.VERTEX_SHADER,t),o=r(e,e.FRAGMENT_SHADER,n),u=e.createProgram();if(!u)throw new Error("can not create shader program");if(e.attachShader(u,i),e.attachShader(u,o),e.linkProgram(u),e.deleteShader(i),e.deleteShader(o),!e.getProgramParameter(u,e.LINK_STATUS))throw new Error("Unable to initialize the shader program: "+e.getProgramInfoLog(u));this.gl=e,this.program=u}use(){this.gl.useProgram(this.program)}setUniform(e,t,n){const r=this.gl.getUniformLocation(this.program,e);switch(t){case"BOOLEAN":return this.gl.uniform1i(r,Number(n));case"INT":return this.gl.uniform1i(r,Math.round(n));case"FLOAT":return this.gl.uniform1f(r,n);case"VEC2":return this.gl.uniform2fv(r,n);case"VEC3":return this.gl.uniform3fv(r,n);case"VEC4":return this.gl.uniform4fv(r,n);case"MAT2":return this.gl.uniformMatrix2fv(r,!1,n);case"MAT3":return this.gl.uniformMatrix3fv(r,!1,n);case"MAT4":return this.gl.uniformMatrix4fv(r,!1,n);default:return}}}var o="#version 300 es\nprecision highp float;\n\nlayout (location = 0) in vec2 position;\n\nout vec2 uv;\n\nvoid main() {\n    uv = (position + 1.) / 2.;\n    gl_Position = vec4(position, 0, 1);\n}\n";const u=document.getElementById("main");u.height=window.innerHeight,u.width=window.innerWidth;const s=u.getContext("webgl2",{premultipliedAlpha:!1});if(!s)throw new Error("webgl2 not available");s.clearColor(0,0,0,0),s.getExtension("EXT_color_buffer_float"),s.getExtension("OES_texture_float_linear");const c=new class{constructor(e,t){this.el=e,this.lockPointer=!1,this.updateRate=1e3/60,this.raf=0,t&&(void 0!==t.lockPointer&&(this.lockPointer=t.lockPointer),void 0!==t.updateRate&&(this.updateRate=t.updateRate)),this.currentlyPressedKeys=new Map,this.mouseInput={x:0,y:0,lastX:0,lastY:0,innerX:0,innerY:0,draging:!1,wheel:0,lastWheel:0};const n=e=>{this.currentlyPressedKeys.set(e.key,!0)},r=e=>{this.currentlyPressedKeys.set(e.key,!1)},i=e=>{this.mouseInput.innerX=e.clientX,this.mouseInput.innerY=e.clientY},o=e=>{this.mouseInput.wheel+=e.deltaY},u=()=>{this.mouseInput.draging=!0},s=()=>{this.mouseInput.draging=!1},c=()=>{e.addEventListener("keydown",n),e.addEventListener("keyup",r),e.addEventListener("mousemove",i),e.addEventListener("mousedown",u),e.addEventListener("mouseup",s),e.addEventListener("wheel",o);let t=0;const c=e=>{e-t>this.updateRate&&(t=e,this.mouseInput.lastX=this.mouseInput.x,this.mouseInput.lastY=this.mouseInput.y,this.mouseInput.x=this.mouseInput.innerX,this.mouseInput.y=this.mouseInput.innerY,this.mouseInput.lastWheel=this.mouseInput.wheel),requestAnimationFrame(c)};this.raf=requestAnimationFrame(c)},a=()=>{e.removeEventListener("keydown",n),e.removeEventListener("keyup",r),e.removeEventListener("mousemove",i),e.removeEventListener("mousedown",u),e.removeEventListener("mouseup",s),e.removeEventListener("wheel",o),cancelAnimationFrame(this.raf)};if(this.lockPointer){e.requestPointerLock=e.requestPointerLock||e.mozRequestPointerLock,e.exitPointerLock=e.exitPointerLock||e.mozExitPointerLock,e.addEventListener("click",e.requestPointerLock);const t=()=>{document.pointerLockElement===e||document.mozPointerLockElement===e?c():a()};document.addEventListener("pointerlockchange",t,!1),document.addEventListener("mozpointerlockchange",t,!1)}else e.contentEditable="true",e.style.cursor="default",e.style.outline="none",c()}}(u),a=new class{constructor(e,t){this.el=e,this.updateRate=1e3/60,this.touchList=[],this.lastTouchList=[],this.innerTouchList=[],this.raf=0,this.t=performance.now(),t&&void 0!==t.updateRate&&(this.updateRate=t.updateRate);e.addEventListener("touchstart",e=>{this.innerTouchList=Array.from(e.touches)},{passive:!0}),e.addEventListener("touchmove",e=>{this.innerTouchList=Array.from(e.touches)},{passive:!0}),e.addEventListener("touchend",e=>{this.innerTouchList=Array.from(e.touches)},{passive:!0});let n=0;const r=e=>{e-n>this.updateRate&&(n=e,this.lastTouchList=this.touchList,this.touchList=this.innerTouchList),requestAnimationFrame(r)};this.raf=requestAnimationFrame(r)}}(u),l=s.createVertexArray(),f=s.createBuffer();s.bindVertexArray(l),s.bindBuffer(s.ARRAY_BUFFER,f),s.bufferData(s.ARRAY_BUFFER,new Float32Array([-1,1,-1,-1,1,1,1,-1]),s.STATIC_DRAW),s.enableVertexAttribArray(0),s.vertexAttribPointer(0,2,s.FLOAT,!0,8,0),s.bindBuffer(s.ARRAY_BUFFER,null);const v=e=>{const t=Object.assign({size:4,resolution:{width:u.clientWidth,height:u.clientHeight},linear:!1},e),n=[[s.R32F,s.RED],[s.RG32F,s.RG],[s.RGB32F,s.RGB],[s.RGBA32F,s.RGBA]],[r,i]=n[t.size-1],o=s.createTexture();s.bindTexture(s.TEXTURE_2D,o),s.texParameteri(s.TEXTURE_2D,s.TEXTURE_MAG_FILTER,t.linear?s.LINEAR:s.NEAREST),s.texParameteri(s.TEXTURE_2D,s.TEXTURE_MIN_FILTER,t.linear?s.LINEAR:s.NEAREST),s.texParameteri(s.TEXTURE_2D,s.TEXTURE_WRAP_S,s.CLAMP_TO_EDGE),s.texParameteri(s.TEXTURE_2D,s.TEXTURE_WRAP_T,s.CLAMP_TO_EDGE),s.texImage2D(s.TEXTURE_2D,0,r,t.resolution.width,t.resolution.height,0,i,s.FLOAT,null);const c=s.createFramebuffer();return s.bindFramebuffer(s.FRAMEBUFFER,c),s.framebufferTexture2D(s.FRAMEBUFFER,s.COLOR_ATTACHMENT0,s.TEXTURE_2D,o,0),s.viewport(0,0,t.resolution.width,t.resolution.height),s.clear(s.COLOR_BUFFER_BIT),{fb:c,tex:o}},m=e=>{const t=[0,1].map(()=>v(e));return{get fb(){return t[0].fb},get tex(){return t[1].tex},swap:()=>t.reverse()}},x=u.clientWidth/u.clientHeight,d=[256*x,256],T=[1/(256*x),1/256],h=m({linear:!0}),E=m({size:2,resolution:{width:d[0],height:d[1]},linear:!0}),y=v({size:1,resolution:{width:d[0],height:d[1]}}),p=v({size:1,resolution:{width:d[0],height:d[1]}}),R=m({size:1,resolution:{width:d[0],height:d[1]}}),g=(()=>{const e=new i(s,o,"#version 300 es\nprecision highp float;\n\nuniform sampler2D velocity;\nuniform vec2 resolution;\n\nuniform vec2 cursor;\nuniform vec2 force;\n\nuniform int pressed;\n\nin vec2 uv;\nout vec2 outVelocity;\n\nvoid main () {\n    vec2 nuv = vec2(uv.x * resolution.x/resolution.y, uv.y);\n\n    vec2 p = nuv - cursor;\n    vec2 base = texture(velocity, uv).xy;\n    float radius = 0.0025;\n    vec2 f = pressed < 1 ? vec2(0.) : force * 10.;\n    vec2 splat = vec2(exp(-dot(p, p) / radius)) * f;\n    outVelocity = base + splat;\n}\n");return e.use(),e.setUniform("resolution","VEC2",[u.clientWidth,u.clientHeight]),e.setUniform("texelSize","VEC2",T),(t,n,r)=>{s.bindFramebuffer(s.FRAMEBUFFER,E.fb),e.use(),s.activeTexture(s.TEXTURE0),s.bindTexture(s.TEXTURE_2D,E.tex),e.setUniform("pressed","BOOLEAN",t),e.setUniform("cursor","VEC2",n),e.setUniform("force","VEC2",r),s.drawArrays(s.TRIANGLE_STRIP,0,4),E.swap()}})(),b=(()=>{const e=new i(s,o,"#version 300 es\nprecision highp float;\n\nuniform sampler2D dye;\nuniform vec2 resolution;\nuniform int pressed;\nuniform vec2 cursor;\nuniform vec3 color;\n\n\nin vec2 uv;\nout vec4 outDye;\n\nvoid main () {\n    vec2 nuv = vec2(uv.x * resolution.x/resolution.y, uv.y);\n\n    vec2 p = nuv - cursor;\n    vec3 base = texture(dye, uv).xyz;\n    float radius = 0.0025;\n    vec3 c = pressed < 1 ? vec3(0.) : color;\n    vec3 splat = exp(-dot(p, p) / radius) * c;\n    outDye = vec4(base + splat, 1.);\n}\n");return e.use(),e.setUniform("resolution","VEC2",[u.clientWidth,u.clientHeight]),(t,n)=>{s.bindFramebuffer(s.FRAMEBUFFER,h.fb),e.use(),s.activeTexture(s.TEXTURE0),s.bindTexture(s.TEXTURE_2D,h.tex),e.setUniform("cursor","VEC2",n),e.setUniform("pressed","BOOLEAN",t),e.setUniform("color","VEC3",[0,.5,1]),s.drawArrays(s.TRIANGLE_STRIP,0,4),h.swap()}})(),U=(()=>{const e=new i(s,o,"#version 300 es\nprecision highp float;\n\nuniform vec2 texelSize;\nuniform sampler2D velocity;\n\nin vec2 uv;\nout float vorticity;\n\nvoid main() {\n    vec2 xOffset = vec2(texelSize.x, 0.0);\n    vec2 yOffset = vec2(0.0, texelSize.y);\n    float L = texture(velocity, uv - xOffset).y;\n    float R = texture(velocity, uv + xOffset).y;\n    float T = texture(velocity, uv + yOffset).x;\n    float B = texture(velocity, uv - yOffset).x;\n    vorticity = (R - L - T + B) * 0.5;\n}\n");return e.use(),e.setUniform("resolution","VEC2",[u.clientWidth,u.clientHeight]),e.setUniform("texelSize","VEC2",T),()=>{s.bindFramebuffer(s.FRAMEBUFFER,y.fb),e.use(),s.activeTexture(s.TEXTURE0),s.bindTexture(s.TEXTURE_2D,E.tex),s.drawArrays(s.TRIANGLE_STRIP,0,4)}})(),A=(()=>{const e=new i(s,o,"#version 300 es\nprecision highp float;\n\nuniform sampler2D velocity;\nuniform sampler2D vorticity;\nuniform vec2 texelSize;\nuniform float curl;\nuniform float dt;\n\nin vec2 uv;\nout vec2 outVelocity;\n\nvoid main() {\n    vec2 xOffset = vec2(texelSize.x, 0.0);\n    vec2 yOffset = vec2(0.0, texelSize.y);\n\n    float L = texture(vorticity, uv - xOffset).x;\n    float R = texture(vorticity, uv + xOffset).x;\n    float T = texture(vorticity, uv + yOffset).x;\n    float B = texture(vorticity, uv - yOffset).x;\n    float C = texture(vorticity, uv).x;\n\n    vec2 force = 0.5 * vec2(abs(T) - abs(B), abs(R) - abs(L));\n    force /= length(force) + 0.0001;\n    force *= curl * C;\n    force.y *= -1.0;\n\n    // vec2 force = 0.5 * vec2(abs(T) - abs(B), abs(R) - abs(L));\n    // float lengthSquared = max(2.4414e-4, dot(force, force));\n    // force *= inversesqrt(lengthSquared) * curl * C;\n    // force.y *= -1.0;\n\n    vec2 vel = texture(velocity, uv).xy;\n    outVelocity = vel + force * dt;\n}\n");return e.use(),e.setUniform("resolution","VEC2",[u.clientWidth,u.clientHeight]),e.setUniform("texelSize","VEC2",T),t=>{s.bindFramebuffer(s.FRAMEBUFFER,E.fb),e.use(),s.activeTexture(s.TEXTURE0),s.bindTexture(s.TEXTURE_2D,E.tex),e.setUniform("velocity","INT",0),s.activeTexture(s.TEXTURE1),s.bindTexture(s.TEXTURE_2D,y.tex),e.setUniform("vorticity","INT",1),e.setUniform("curl","FLOAT",25),e.setUniform("dt","FLOAT",t),s.drawArrays(s.TRIANGLE_STRIP,0,4),E.swap()}})(),L=(()=>{const e=new i(s,o,"#version 300 es\nprecision highp float;\n\nuniform vec2 texelSize;\nuniform sampler2D velocity;\n\nin vec2 uv;\nout float outDivergence;\n\nvoid main () {\n    vec2 xOffset = vec2(texelSize.x, 0.0);\n    vec2 yOffset = vec2(0.0, texelSize.y);\n    float L = texture(velocity, uv - xOffset).x;\n    float R = texture(velocity, uv + xOffset).x;\n    float T = texture(velocity, uv + yOffset).y;\n    float B = texture(velocity, uv - yOffset).y;\n\n    vec2 C = texture(velocity, uv).xy;\n    if (uv.x - xOffset.x < 0.0) { L = -C.x; }\n    if (uv.x + xOffset.x > 1.0) { R = -C.x; }\n    if (uv.y + yOffset.y > 1.0) { T = -C.y; }\n    if (uv.y - yOffset.y < 0.0) { B = -C.y; }\n\n    outDivergence = 0.5 * (R - L + T - B);\n}\n");return e.use(),e.setUniform("resolution","VEC2",[u.clientWidth,u.clientHeight]),e.setUniform("texelSize","VEC2",T),()=>{s.bindFramebuffer(s.FRAMEBUFFER,p.fb),e.use(),s.activeTexture(s.TEXTURE0),s.bindTexture(s.TEXTURE_2D,E.tex),s.drawArrays(s.TRIANGLE_STRIP,0,4)}})(),F=(()=>{const e=new i(s,o,"#version 300 es\nprecision highp float;\n\nuniform float value;\nuniform sampler2D uPressure;\n\nin vec2 uv;\nout float outPressure;\n\nvoid main () {\n    outPressure = value * texture(uPressure, uv).x;\n}\n");return e.setUniform("resolution","VEC2",[u.clientWidth,u.clientHeight]),e.setUniform("texelSize","VEC2",T),()=>{s.bindFramebuffer(s.FRAMEBUFFER,R.fb),e.use(),s.activeTexture(s.TEXTURE0),s.bindTexture(s.TEXTURE_2D,R.tex),e.setUniform("value","FLOAT",.8),s.drawArrays(s.TRIANGLE_STRIP,0,4),R.swap()}})(),S=(()=>{const e=new i(s,o,"#version 300 es\nprecision highp float;\n\nuniform vec2 texelSize;\nuniform sampler2D uDivergence;\nuniform sampler2D uPressure;\n\nin vec2 uv;\nout float outPressure;\n\nvoid main () {\n\n    vec2 xOffset = vec2(texelSize.x, 0.0);\n    vec2 yOffset = vec2(0.0, texelSize.y);\n    float L = texture(uPressure, uv - xOffset).x;\n    float R = texture(uPressure, uv + xOffset).x;\n    float T = texture(uPressure, uv + yOffset).x;\n    float B = texture(uPressure, uv - yOffset).x;\n    float C = texture(uPressure, uv).x;\n    float divergence = texture(uDivergence, uv).x;\n    outPressure = (L + R + B + T - divergence) * 0.25;\n}\n");return e.use(),e.setUniform("resolution","VEC2",[u.clientWidth,u.clientHeight]),e.setUniform("texelSize","VEC2",T),()=>{for(let t=0;t<20;t++)s.bindFramebuffer(s.FRAMEBUFFER,R.fb),e.use(),s.activeTexture(s.TEXTURE0),s.bindTexture(s.TEXTURE_2D,p.tex),e.setUniform("uDivergence","INT",0),s.activeTexture(s.TEXTURE1),s.bindTexture(s.TEXTURE_2D,R.tex),e.setUniform("uPressure","INT",1),s.drawArrays(s.TRIANGLE_STRIP,0,4),R.swap()}})(),w=(()=>{const e=new i(s,o,"#version 300 es\nprecision highp float;\n\nuniform vec2 texelSize;\nuniform sampler2D uPressure;\nuniform sampler2D uVelocity;\n\nin vec2 uv;\nout vec2 outVelocity;\n\nvoid main () {\n    vec2 xOffset = vec2(texelSize.x, 0.0);\n    vec2 yOffset = vec2(0.0, texelSize.y);\n    float L = texture(uPressure, uv - xOffset).x;\n    float R = texture(uPressure, uv + xOffset).x;\n    float T = texture(uPressure, uv + yOffset).x;\n    float B = texture(uPressure, uv - yOffset).x;\n    outVelocity = texture(uVelocity, uv).xy - vec2(R - L, T - B);\n}\n\n\n");return e.use(),e.setUniform("resolution","VEC2",[u.clientWidth,u.clientHeight]),e.setUniform("texelSize","VEC2",T),()=>{s.bindFramebuffer(s.FRAMEBUFFER,E.fb),e.use(),s.activeTexture(s.TEXTURE0),s.bindTexture(s.TEXTURE_2D,R.tex),e.setUniform("uPressure","INT",0),s.activeTexture(s.TEXTURE1),s.bindTexture(s.TEXTURE_2D,E.tex),e.setUniform("uVelocity","INT",1),s.drawArrays(s.TRIANGLE_STRIP,0,4),E.swap()}})(),P=(()=>{const e=new i(s,o,"#version 300 es\nprecision highp float;\n\nuniform sampler2D uVelocity;\n\nuniform vec2 resolution;\nuniform vec2 texelSize;\n// uniform vec2 dyeTexelSize;\nuniform float dt;\nuniform float dissipation;\n\nin vec2 uv;\nout vec2 outVelocity;\n\n// vec4 bilerp (sampler2D sam, vec2 uv, vec2 tsize) {\n//     vec2 st = uv / tsize - 0.5;\n//     vec2 iuv = floor(st);\n//     vec2 fuv = fract(st);\n//     vec4 a = texture(sam, (iuv + vec2(0.5, 0.5)) * tsize);\n//     vec4 b = texture(sam, (iuv + vec2(1.5, 0.5)) * tsize);\n//     vec4 c = texture(sam, (iuv + vec2(0.5, 1.5)) * tsize);\n//     vec4 d = texture(sam, (iuv + vec2(1.5, 1.5)) * tsize);\n//     return mix(mix(a, b, fuv.x), mix(c, d, fuv.x), fuv.y);\n// }\n\nvoid main () {\n\n    // vec2 coord = uv - dt * bilerp(uVelocity, uv, texelSize).xy * texelSize;\n    // vec4 result = bilerp(uSource, coord, uv/resolution);\n\n    vec2 coord = uv - dt * texture(uVelocity, uv).xy * texelSize;\n    vec2 result = texture(uVelocity, coord).xy;\n\n    float decay = 1.0 + dissipation * dt;\n    outVelocity = result.xy / decay;\n}\n");return e.use(),e.setUniform("resolution","VEC2",[u.clientWidth,u.clientHeight]),e.setUniform("texelSize","VEC2",T),t=>{s.bindFramebuffer(s.FRAMEBUFFER,E.fb),e.use(),s.activeTexture(s.TEXTURE0),s.bindTexture(s.TEXTURE_2D,E.tex),e.setUniform("dt","FLOAT",t),e.setUniform("dissipation","FLOAT",1),s.drawArrays(s.TRIANGLE_STRIP,0,4),E.swap()}})(),_=(()=>{const e=new i(s,o,"#version 300 es\nprecision highp float;\n\nuniform sampler2D uVelocity;\nuniform sampler2D uSource;\n\nuniform vec2 resolution;\nuniform vec2 texelSize;\n// uniform vec2 dyeTexelSize;\nuniform float dt;\nuniform float dissipation;\n\nin vec2 uv;\nout vec4 outDye;\n\n// vec4 bilerp (sampler2D sam, vec2 uv, vec2 tsize) {\n//     vec2 st = uv / tsize - 0.5;\n//     vec2 iuv = floor(st);\n//     vec2 fuv = fract(st);\n//     vec4 a = texture(sam, (iuv + vec2(0.5, 0.5)) * tsize);\n//     vec4 b = texture(sam, (iuv + vec2(1.5, 0.5)) * tsize);\n//     vec4 c = texture(sam, (iuv + vec2(0.5, 1.5)) * tsize);\n//     vec4 d = texture(sam, (iuv + vec2(1.5, 1.5)) * tsize);\n//     return mix(mix(a, b, fuv.x), mix(c, d, fuv.x), fuv.y);\n// }\n\nvoid main () {\n\n    // vec2 coord = uv - dt * bilerp(uVelocity, uv, texelSize).xy * texelSize;\n    // vec4 result = bilerp(uSource, coord, dyeTexelSize);\n\n    vec2 coord = uv - dt * texture(uVelocity, uv).xy * texelSize;\n    vec4 result = texture(uSource, coord);\n\n    float decay = 1.0 + dissipation * dt;\n    outDye = result / decay;\n}\n");return e.use(),e.setUniform("resolution","VEC2",[u.clientWidth,u.clientHeight]),e.setUniform("texelSize","VEC2",T),t=>{s.bindFramebuffer(s.FRAMEBUFFER,h.fb),e.use(),s.activeTexture(s.TEXTURE0),s.bindTexture(s.TEXTURE_2D,E.tex),e.setUniform("uVelocity","INT",0),s.activeTexture(s.TEXTURE1),s.bindTexture(s.TEXTURE_2D,h.tex),e.setUniform("uSource","INT",1),e.setUniform("dt","FLOAT",t),e.setUniform("dissipation","FLOAT",.5),s.drawArrays(s.TRIANGLE_STRIP,0,4),h.swap()}})(),O=(()=>{const e=new i(s,o,"#version 300 es\nprecision highp float;\nuniform vec2 texelSize;\nuniform sampler2D uTarget;\n\nin vec2 uv;\nout vec4 fragColor;\n\nvoid main () {\n    fragColor = texture(uTarget, uv);\n    // fragColor = (texture(uTarget, uv) + 1.)/2.;\n}\n");return e.use(),e.setUniform("resolution","VEC2",[u.clientWidth,u.clientHeight]),t=>{e.use(),s.activeTexture(s.TEXTURE0),s.bindTexture(s.TEXTURE_2D,t),s.bindFramebuffer(s.FRAMEBUFFER,null),s.drawArrays(s.TRIANGLE_STRIP,0,4)}})();let I=0,z=0;s.viewport(0,0,u.clientWidth,u.clientHeight);const D=e=>{z=(e-I)/1e3,I=e;let t=c.mouseInput.draging,n=[c.mouseInput.x,c.mouseInput.y],r=[c.mouseInput.lastX,c.mouseInput.lastY];a.touchList[0]&&a.lastTouchList[0]&&(t=!0,n=[a.touchList[0].clientX,a.touchList[0].clientY],r=[a.lastTouchList[0].clientX,a.lastTouchList[0].clientY]);const i=[n[0]/u.clientHeight,1-n[1]/u.clientHeight],o=[n[0]-r[0],r[1]-n[1]];b(t,i),s.viewport(0,0,d[0],d[1]),g(t,i,o),U(),A(z),L(),F(),S(),w(),P(z),s.viewport(0,0,u.clientWidth,u.clientHeight),_(z),O(h.tex),requestAnimationFrame(D)};requestAnimationFrame(D)}]);